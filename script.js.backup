// ROFLFaucet JavaScript - Clean API Integration
// Username-based system connecting to Express backend

class ROFLFaucet {
    constructor() {
        this.apiBase = window.location.origin;
        this.userId = localStorage.getItem('roflfaucet_userId');
        this.username = localStorage.getItem('roflfaucet_username');
        this.userStats = {
            balance: 0,
            totalClaims: 0,
            canClaim: true,
            nextClaimTime: null
        };
        
        this.init();
    }

    init() {
        this.setupEventListeners();
        this.checkUserSession();
        this.loadGlobalStats();
        this.startPeriodicUpdates();
    }

    setupEventListeners() {
        // Claim button
        const claimBtn = document.getElementById('claim-btn');
        if (claimBtn) {
            claimBtn.addEventListener('click', () => this.handleClaim());
        }

        // Username input and signup
        const usernameInput = document.getElementById('username-input');
        const signupBtn = document.getElementById('signup-btn');
        
        if (usernameInput && signupBtn) {
            signupBtn.addEventListener('click', () => this.handleSignup());
            usernameInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') this.handleSignup();
            });
        }

        // Refresh stats button
        const refreshBtn = document.getElementById('refresh-stats');
        if (refreshBtn) {
            refreshBtn.addEventListener('click', () => this.loadUserStats());
        }

        // Vote buttons (placeholder for future)
        document.querySelectorAll('.vote-btn').forEach(btn => {
            btn.addEventListener('click', (e) => this.handleVote(e.target.dataset.project));
        });

        // Navigation
        this.setupNavigation();
    }

    // Check if user has existing session
    async checkUserSession() {
        if (this.userId && this.username) {
            await this.loadUserStats();
            this.showUserInterface();
        } else {
            this.showSignupInterface();
        }
    }

    // Handle user signup
    async handleSignup() {
        const usernameInput = document.getElementById('username-input');
        const username = usernameInput?.value?.trim();
        
        if (!username) {
            this.showMessage('Please enter a username', 'error');
            return;
        }
        
        if (username.length < 3) {
            this.showMessage('Username must be at least 3 characters', 'error');
            return;
        }
        
        try {
            const response = await fetch(`${this.apiBase}/api/user/create`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ username })
            });
            
            const data = await response.json();
            
            if (response.ok) {
                this.userId = data.userId;
                this.username = data.username;
                
                // Save to localStorage
                localStorage.setItem('roflfaucet_userId', this.userId);
                localStorage.setItem('roflfaucet_username', this.username);
                
                this.userStats = {
                    balance: data.balance,
                    totalClaims: data.totalClaims,
                    canClaim: data.canClaim,
                    nextClaimTime: null
                };
                
                this.showUserInterface();
                this.updateUI();
                this.showMessage(`Welcome, ${this.username}! You can claim your first tokens now.`, 'success');
            } else {
                this.showMessage(data.error || 'Failed to create user', 'error');
            }
        } catch (error) {
            console.error('Signup error:', error);
            this.showMessage('Connection error. Please try again.', 'error');
        }
    }

    // Handle token claim
    async handleClaim() {
        if (!this.userId) {
            this.showMessage('Please sign up first!', 'error');
            return;
        }
        
        if (!this.userStats.canClaim) {
            const nextClaim = this.userStats.nextClaimTime;
            if (nextClaim) {
                this.showMessage(`You can claim again at ${nextClaim.toLocaleTimeString()}`, 'warning');
            }
            return;
        }
        
        const claimBtn = document.getElementById('claim-btn');
        const originalText = claimBtn?.querySelector('.btn-text')?.textContent;
        
        try {
            if (claimBtn) {
                claimBtn.disabled = true;
                const btnText = claimBtn.querySelector('.btn-text');
                const btnLoading = claimBtn.querySelector('.btn-loading');
                if (btnText) btnText.style.display = 'none';
                if (btnLoading) btnLoading.style.display = 'inline';
            }
            
            const response = await fetch(`${this.apiBase}/api/claim`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ userId: this.userId })
            });
            
            const data = await response.json();
            
            if (response.ok) {
                this.userStats.balance = data.newBalance;
                this.userStats.totalClaims = data.totalClaims;
                this.userStats.canClaim = false;
                this.userStats.nextClaimTime = new Date(data.nextClaimAvailable);
                
                this.showMessage(data.message, 'success');
                this.updateUI();
                this.startCountdown();
                this.loadGlobalStats(); // Refresh global stats
            } else {
                this.showMessage(data.error || 'Claim failed', 'error');
            }
        } catch (error) {
            console.error('Claim error:', error);
            this.showMessage('Connection error. Please try again.', 'error');
        } finally {
            if (claimBtn) {
                claimBtn.disabled = false;
                const btnText = claimBtn.querySelector('.btn-text');
                const btnLoading = claimBtn.querySelector('.btn-loading');
                if (btnText) {
                    btnText.style.display = 'inline';
                    btnText.textContent = originalText;
                }
                if (btnLoading) btnLoading.style.display = 'none';
            }
        }
    }

    // Load user statistics from API
    async loadUserStats() {
        if (!this.userId) return;
        
        try {
            const response = await fetch(`${this.apiBase}/api/user/${this.userId}`);
            const data = await response.json();
            
            if (response.ok) {
                this.userStats = {
                    balance: data.balance,
                    totalClaims: data.totalClaims,
                    canClaim: data.canClaim,
                    nextClaimTime: data.nextClaimAvailable ? new Date(data.nextClaimAvailable) : null
                };
                
                this.updateUI();
                if (!this.userStats.canClaim && this.userStats.nextClaimTime) {
                    this.startCountdown();
                }
            } else {
                console.error('Failed to load user stats:', data.error);
            }
        } catch (error) {
            console.error('Stats loading error:', error);
        }
    }

    // Load global faucet statistics
    async loadGlobalStats() {
        try {
            const response = await fetch(`${this.apiBase}/api/stats`);
            const data = await response.json();
            
            if (response.ok) {
                const totalUsersEl = document.getElementById('total-users');
                const totalClaimsEl = document.getElementById('total-claims');
                const totalTokensEl = document.getElementById('total-tokens');
                
                if (totalUsersEl) totalUsersEl.textContent = data.totalUsers;
                if (totalClaimsEl) totalClaimsEl.textContent = data.totalClaims;
                if (totalTokensEl) totalTokensEl.textContent = `${data.totalTokensDistributed} UC`;
            }
        } catch (error) {
            console.error('Global stats loading error:', error);
        }
    }

    // Update UI elements
    updateUI() {
        // Update username display
        const usernameDisplay = document.getElementById('username-display');
        if (usernameDisplay && this.username) {
            usernameDisplay.textContent = this.username;
        }
        
        // Update balance
        const balanceDisplay = document.getElementById('balance-display');
        if (balanceDisplay) {
            balanceDisplay.textContent = this.userStats.balance || 0;
        }
        
        // Update total claims
        const claimsDisplay = document.getElementById('claims-display');
        if (claimsDisplay) {
            claimsDisplay.textContent = this.userStats.totalClaims || 0;
        }
        
        // Update claim button
        const claimBtn = document.getElementById('claim-btn');
        if (claimBtn) {
            const btnText = claimBtn.querySelector('.btn-text');
            claimBtn.disabled = !this.userStats.canClaim;
            if (btnText) {
                btnText.textContent = this.userStats.canClaim ? '🚀 Claim UselessCoins!' : '⏰ Cooldown Active';
            }
        }
        
        // Update countdown display
        const countdownTimer = document.querySelector('.claim-timer');
        if (countdownTimer) {
            countdownTimer.style.display = this.userStats.canClaim ? 'none' : 'block';
        }
    }

    // Show/hide interface elements
    showSignupInterface() {
        const signupSection = document.getElementById('signup-section');
        const userSection = document.getElementById('user-section');
        
        if (signupSection) signupSection.style.display = 'block';
        if (userSection) userSection.style.display = 'none';
    }
    
    showUserInterface() {
        const signupSection = document.getElementById('signup-section');
        const userSection = document.getElementById('user-section');
        
        if (signupSection) signupSection.style.display = 'none';
        if (userSection) userSection.style.display = 'block';
    }

    // Show messages to user
    showMessage(message, type = 'info') {
        const messageDiv = document.getElementById('message-display');
        if (!messageDiv) {
            console.log(`${type.toUpperCase()}: ${message}`);
            return;
        }
        
        messageDiv.textContent = message;
        messageDiv.className = `message-display message ${type}`;
        messageDiv.style.display = 'block';
        
        // Auto-hide after 5 seconds
        setTimeout(() => {
            messageDiv.style.display = 'none';
        }, 5000);
    }

    // Start countdown timer
    startCountdown() {
        if (!this.userStats.nextClaimTime) return;
        
        const updateCountdown = () => {
            const now = new Date();
            const timeLeft = this.userStats.nextClaimTime - now;
            
            if (timeLeft <= 0) {
                this.userStats.canClaim = true;
                this.updateUI();
                return;
            }
            
            const minutes = Math.floor(timeLeft / 60000);
            const seconds = Math.floor((timeLeft % 60000) / 1000);
            
            const countdownDisplay = document.getElementById('countdown-display');
            if (countdownDisplay) {
                countdownDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }
            
            setTimeout(updateCountdown, 1000);
        };
        
        updateCountdown();
    }

    // Start periodic updates
    startPeriodicUpdates() {
        // Update stats every 30 seconds
        setInterval(() => {
            if (this.userId) {
                this.loadUserStats();
            }
            this.loadGlobalStats();
        }, 30000);
    }

    // Setup smooth navigation
    setupNavigation() {
        document.querySelectorAll('.nav-link').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const target = document.querySelector(link.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({ behavior: 'smooth' });
                    
                    // Update active nav
                    document.querySelectorAll('.nav-link').forEach(l => l.classList.remove('active'));
                    link.classList.add('active');
                }
            });
        });
    }

    // Placeholder for future vote functionality
    handleVote(project) {
        this.showMessage('Charity voting will be available soon!', 'info');
    }
}

// Initialize the faucet when page loads
document.addEventListener('DOMContentLoaded', () => {
    window.roflfaucet = new ROFLFaucet();
});

// Add CSS for messages
const style = document.createElement('style');
style.textContent = `
    .message {
        padding: 12px 16px;
        margin: 10px 0;
        border-radius: 6px;
        font-weight: 500;
        border-left: 4px solid;
    }
    .message.success {
        background-color: #d4edda;
        color: #155724;
        border-left-color: #28a745;
    }
    .message.error {
        background-color: #f8d7da;
        color: #721c24;
        border-left-color: #dc3545;
    }
    .message.warning {
        background-color: #fff3cd;
        color: #856404;
        border-left-color: #ffc107;
    }
    .message.info {
        background-color: #d1ecf1;
        color: #0c5460;
        border-left-color: #17a2b8;
    }
    .signup-section {
        text-align: center;
        padding: 20px;
    }
    .username-input {
        margin: 15px 0;
    }
    .username-input label {
        display: block;
        margin-bottom: 8px;
        font-weight: 500;
    }
    .username-input input {
        width: 100%;
        max-width: 300px;
        padding: 12px;
        border: 2px solid #e9ecef;
        border-radius: 6px;
        font-size: 16px;
    }
    .username-input input:focus {
        border-color: #007bff;
        outline: none;
    }
    .signup-button, .refresh-button {
        background: linear-gradient(135deg, #007bff, #0056b3);
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 6px;
        font-size: 16px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.3s ease;
    }
    .signup-button:hover, .refresh-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0,123,255,0.3);
    }
    .user-section {
        text-align: center;
        padding: 20px;
    }
    .user-stats {
        display: flex;
        justify-content: space-around;
        margin: 20px 0;
        flex-wrap: wrap;
    }
    .stat-item {
        margin: 10px;
    }
    .stat-label {
        display: block;
        font-size: 14px;
        color: #666;
        margin-bottom: 4px;
    }
    .stat-value {
        font-size: 24px;
        font-weight: bold;
        color: #007bff;
    }
    .refresh-button {
        margin-top: 15px;
        background: linear-gradient(135deg, #28a745, #1e7e34);
    }
`;
document.head.appendChild(style);

// Global helper functions
function showCharityPromotion() {
    const votingSection = document.getElementById('voting');
    if (votingSection) {
        votingSection.scrollIntoView({ behavior: 'smooth' });
    }
}

function showAchievements() {
    const achievementsSection = document.getElementById('achievements');
    if (achievementsSection) {
        achievementsSection.scrollIntoView({ behavior: 'smooth' });
    }
}

    updateClaimButton() {
        const claimBtn = document.getElementById('claim-btn');
        const walletInput = document.getElementById('wallet-address');
        const hcaptchaResponse = document.querySelector('.h-captcha textarea');
        
        if (!claimBtn) return;
        
        const hasWallet = this.userAddress && walletInput && walletInput.value.length > 0;
        const hasCaptcha = hcaptchaResponse && hcaptchaResponse.value.length > 0;
        const canClaim = this.canClaimNow();
        
        const isEnabled = hasWallet && hasCaptcha && canClaim;
        
        claimBtn.disabled = !isEnabled;
        
        if (!canClaim) {
            claimBtn.querySelector('.btn-text').textContent = '⏰ Cooldown Active';
        } else if (!hasWallet) {
            claimBtn.querySelector('.btn-text').textContent = '📱 Enter Wallet Address';
        } else if (!hasCaptcha) {
            claimBtn.querySelector('.btn-text').textContent = '🤖 Complete Captcha';
        } else {
            claimBtn.querySelector('.btn-text').textContent = '🚀 Claim Tokens';
        }
    }

    canClaimNow() {
        if (!this.lastClaimTime) return true;
        
        const now = Date.now();
        const timeDiff = (now - this.lastClaimTime) / 1000;
        return timeDiff >= this.claimCooldown;
    }

    async handleClaim() {
        const claimBtn = document.getElementById('claim-btn');
        const hcaptchaResponse = document.querySelector('.h-captcha textarea');
        
        if (!this.userAddress || !hcaptchaResponse || !hcaptchaResponse.value) {
            this.showError('Please complete all requirements before claiming.');
            return;
        }

        // Show loading state
        claimBtn.disabled = true;
        claimBtn.querySelector('.btn-text').style.display = 'none';
        claimBtn.querySelector('.btn-loading').style.display = 'inline';

        try {
            // Simulate API call for now (replace with actual endpoint)
            await this.simulateApiCall();
            
            // Success!
            this.processClaim();
            
        } catch (error) {
            console.error('Claim error:', error);
            this.showError('Claim failed. Please try again.');
        }

        // Reset button state
        claimBtn.querySelector('.btn-text').style.display = 'inline';
        claimBtn.querySelector('.btn-loading').style.display = 'none';
        this.updateClaimButton();
        
        // Reset hCaptcha
        if (window.hcaptcha) {
            window.hcaptcha.reset();
        }
    }

    async simulateApiCall() {
        // Simulate network delay
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                // 95% success rate for demo
                if (Math.random() < 0.95) {
                    resolve({ success: true, amount: 0.00001 });
                } else {
                    reject(new Error('Network error'));
                }
            }, 2000);
        });
    }

    processClaim() {
        const claimAmount = 0.00001;
        
        // Update last claim time
        this.lastClaimTime = Date.now();
        localStorage.setItem('roflfaucet_last_claim', this.lastClaimTime.toString());
        
        // Update user stats
        this.userStats.totalClaims = (this.userStats.totalClaims || 0) + 1;
        this.userStats.totalEarned = (this.userStats.totalEarned || 0) + claimAmount;
        this.userStats.todayClaims = (this.userStats.todayClaims || 0) + 1;
        this.userStats.votingPower = (this.userStats.votingPower || 0) + 1;
        this.saveUserStats();
        
        // Show success message
        this.showSuccessMessage(claimAmount);
        
        // Update UI
        this.updateStats();
        this.startCountdown();
        
        // Check for achievements
        this.checkAchievements();
        
        // Track first claim achievement
        if (this.userStats.totalClaims === 1) {
            this.unlockAchievement('first_claim');
        }
    }

    showSuccessMessage(amount) {
        const successMsg = document.getElementById('success-message');
        const claimedAmount = document.getElementById('claimed-amount');
        
        if (successMsg && claimedAmount) {
            claimedAmount.textContent = amount.toFixed(8);
            successMsg.style.display = 'block';
            successMsg.scrollIntoView({ behavior: 'smooth' });
            
            // Hide after 10 seconds
            setTimeout(() => {
                successMsg.style.display = 'none';
            }, 10000);
        }
    }

    showError(message) {
        // Create temporary error message
        const errorDiv = document.createElement('div');
        errorDiv.className = 'error-message';
        errorDiv.innerHTML = `
            <div class="error-content">
                <h3>❌ Error</h3>
                <p>${message}</p>
            </div>
        `;
        errorDiv.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--danger-color);
            color: white;
            padding: 1rem 2rem;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            z-index: 1000;
            animation: slideIn 0.3s ease;
        `;
        
        document.body.appendChild(errorDiv);
        
        setTimeout(() => {
            errorDiv.remove();
        }, 5000);
    }

    startCountdown() {
        const countdownElement = document.getElementById('countdown');
        const timerElement = document.querySelector('.claim-timer');
        
        if (!countdownElement || !timerElement) return;
        
        const updateCountdown = () => {
            if (!this.lastClaimTime) {
                timerElement.style.display = 'none';
                return;
            }
            
            const now = Date.now();
            const timeDiff = (now - this.lastClaimTime) / 1000;
            const remaining = this.claimCooldown - timeDiff;
            
            if (remaining <= 0) {
                timerElement.style.display = 'none';
                this.updateClaimButton();
                return;
            }
            
            const minutes = Math.floor(remaining / 60);
            const seconds = Math.floor(remaining % 60);
            
            countdownElement.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            timerElement.style.display = 'block';
            
            setTimeout(updateCountdown, 1000);
        };
        
        updateCountdown();
    }

    updateStats() {
        // Update today's claims
        const todayClaimsEl = document.getElementById('today-claims');
        if (todayClaimsEl) {
            todayClaimsEl.textContent = this.userStats.todayClaims || 0;
        }
        
        // Update user balance
        const userBalanceEl = document.getElementById('user-balance');
        if (userBalanceEl) {
            const balance = (this.userStats.totalEarned || 0).toFixed(8);
            userBalanceEl.textContent = `${balance} USELESS`;
        }
    }

    async handleVote(projectId) {
        if (!this.userStats.votingPower || this.userStats.votingPower < 1) {
            this.showError('You need to claim tokens first to get voting power!');
            return;
        }
        
        // Check if already voted for this project
        const votedProjects = this.userStats.votedProjects || [];
        if (votedProjects.includes(projectId)) {
            this.showError('You have already voted for this project!');
            return;
        }
        
        try {
            // Simulate vote API call
            await this.simulateVoteCall(projectId);
            
            // Update user stats
            this.userStats.votingPower -= 1;
            this.userStats.totalVotes = (this.userStats.totalVotes || 0) + 1;
            this.userStats.votedProjects = [...votedProjects, projectId];
            this.saveUserStats();
            
            // Update vote button
            const voteBtn = document.querySelector(`[data-project="${projectId}"]`);
            if (voteBtn) {
                voteBtn.textContent = '✅ Voted';
                voteBtn.disabled = true;
                voteBtn.style.background = 'var(--success-color)';
            }
            
            // Check achievements
            if (this.userStats.totalVotes === 1) {
                this.unlockAchievement('democracy_supporter');
            }
            
            this.showVoteSuccess(projectId);
            
        } catch (error) {
            console.error('Vote error:', error);
            this.showError('Vote failed. Please try again.');
        }
    }

    async simulateVoteCall(projectId) {
        return new Promise((resolve) => {
            setTimeout(() => resolve({ success: true }), 1000);
        });
    }

    showVoteSuccess(projectId) {
        const successDiv = document.createElement('div');
        successDiv.innerHTML = `
            <div style="
                position: fixed;
                top: 20px;
                right: 20px;
                background: var(--success-color);
                color: white;
                padding: 1rem 2rem;
                border-radius: var(--border-radius);
                box-shadow: var(--shadow);
                z-index: 1000;
                animation: slideIn 0.3s ease;
            ">
                <h4>🗳️ Vote Recorded!</h4>
                <p>Thank you for supporting charity projects!</p>
            </div>
        `;
        
        document.body.appendChild(successDiv);
        
        setTimeout(() => {
            successDiv.remove();
        }, 4000);
    }

    checkAchievements() {
        const achievements = {
            'first_claim': () => (this.userStats.totalClaims || 0) >= 1,
            'democracy_supporter': () => (this.userStats.totalVotes || 0) >= 1,
            'daily_streak': () => (this.userStats.dailyStreak || 0) >= 7,
            'charity_champion': () => (this.userStats.totalVotes || 0) >= 10,
        };
        
        Object.keys(achievements).forEach(achievementId => {
            if (!this.achievements[achievementId] && achievements[achievementId]()) {
                this.unlockAchievement(achievementId);
            }
        });
    }

    unlockAchievement(achievementId) {
        if (this.achievements[achievementId]) return;
        
        this.achievements[achievementId] = {
            unlocked: true,
            unlockedAt: Date.now()
        };
        this.saveAchievements();
        
        // Update UI
        const achievementCard = document.querySelector(`.achievement-card[data-achievement="${achievementId}"]`);
        if (achievementCard) {
            achievementCard.classList.add('unlocked');
            achievementCard.querySelector('.achievement-status').textContent = '✅ Unlocked';
        }
        
        // Show notification
        this.showAchievementNotification(achievementId);
        
        // Award bonus tokens
        this.awardAchievementBonus(achievementId);
    }

    showAchievementNotification(achievementId) {
        const achievementNames = {
            'first_claim': 'First Claim',
            'democracy_supporter': 'Democracy Supporter',
            'satoshihost_supporter': 'SatoshiHost Supporter',
            'daily_streak': 'Daily Streak',
            'charity_champion': 'Charity Champion',
            'ecosystem_learner': 'Ecosystem Learner'
        };
        
        const notification = document.createElement('div');
        notification.innerHTML = `
            <div style="
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, var(--success-color), var(--secondary-color));
                color: white;
                padding: 2rem;
                border-radius: var(--border-radius);
                box-shadow: var(--shadow-hover);
                z-index: 1001;
                text-align: center;
                min-width: 300px;
                animation: slideIn 0.5s ease;
            ">
                <h2>🏆 Achievement Unlocked!</h2>
                <h3>${achievementNames[achievementId] || achievementId}</h3>
                <p>You've earned bonus tokens!</p>
                <button onclick="this.parentElement.parentElement.remove()" style="
                    background: rgba(255,255,255,0.2);
                    border: none;
                    color: white;
                    padding: 0.5rem 1rem;
                    border-radius: 20px;
                    cursor: pointer;
                    margin-top: 1rem;
                ">Awesome! 🎉</button>
            </div>
        `;
        
        document.body.appendChild(notification);
        
        // Auto-remove after 5 seconds
        setTimeout(() => {
            if (notification.parentElement) {
                notification.remove();
            }
        }, 5000);
    }

    awardAchievementBonus(achievementId) {
        const bonuses = {
            'first_claim': 0.00001,
            'democracy_supporter': 0.000025,
            'satoshihost_supporter': 0.000025,
            'daily_streak': 0.0001,
            'charity_champion': 0.0002,
            'ecosystem_learner': 0.00005
        };
        
        const bonus = bonuses[achievementId] || 0;
        if (bonus > 0) {
            this.userStats.totalEarned = (this.userStats.totalEarned || 0) + bonus;
            this.saveUserStats();
            this.updateStats();
        }
    }

    trackEcosystemInteractions() {
        // Track SatoshiHost link clicks
        document.querySelectorAll('a[href*="satoshihost.com"]').forEach(link => {
            link.addEventListener('click', () => {
                // Track achievement
                setTimeout(() => {
                    if (!this.achievements['satoshihost_supporter']) {
                        this.unlockAchievement('satoshihost_supporter');
                    }
                }, 5000); // Give time for the page to load
            });
        });
        
        // Track ecosystem page views
        if (window.location.hash === '#about') {
            setTimeout(() => {
                if (!this.achievements['ecosystem_learner']) {
                    this.unlockAchievement('ecosystem_learner');
                }
            }, 10000); // After spending 10 seconds on about section
        }
    }

    // Data persistence methods
    getLastClaimTime() {
        const stored = localStorage.getItem('roflfaucet_last_claim');
        return stored ? parseInt(stored) : null;
    }

    loadUserStats() {
        const stored = localStorage.getItem('roflfaucet_stats');
        return stored ? JSON.parse(stored) : {
            totalClaims: 0,
            totalEarned: 0,
            todayClaims: 0,
            totalVotes: 0,
            votingPower: 0,
            dailyStreak: 0,
            votedProjects: []
        };
    }

    saveUserStats() {
        localStorage.setItem('roflfaucet_stats', JSON.stringify(this.userStats));
    }

    loadAchievements() {
        const stored = localStorage.getItem('roflfaucet_achievements');
        return stored ? JSON.parse(stored) : {};
    }

    saveAchievements() {
        localStorage.setItem('roflfaucet_achievements', JSON.stringify(this.achievements));
    }

    updateUI() {
        // Update achievement cards based on saved state
        Object.keys(this.achievements).forEach(achievementId => {
            if (this.achievements[achievementId] && this.achievements[achievementId].unlocked) {
                const card = document.querySelector(`.achievement-card[data-achievement="${achievementId}"]`);
                if (card) {
                    card.classList.add('unlocked');
                    card.querySelector('.achievement-status').textContent = '✅ Unlocked';
                }
            }
        });
        
        // Update voted project buttons
        const votedProjects = this.userStats.votedProjects || [];
        votedProjects.forEach(projectId => {
            const voteBtn = document.querySelector(`[data-project="${projectId}"]`);
            if (voteBtn) {
                voteBtn.textContent = '✅ Voted';
                voteBtn.disabled = true;
                voteBtn.style.background = 'var(--success-color)';
            }
        });
    }
}

// Initialize the faucet when page loads
document.addEventListener('DOMContentLoaded', () => {
    window.roflfaucet = new ROFLFaucet();
});

// Add some basic CSS for messages
const style = document.createElement('style');
style.textContent = `
    .message {
        padding: 10px;
        margin: 10px 0;
        border-radius: 5px;
        font-weight: bold;
    }
    .message.success {
        background-color: #d4edda;
        color: #155724;
        border: 1px solid #c3e6cb;
    }
    .message.error {
        background-color: #f8d7da;
        color: #721c24;
        border: 1px solid #f5c6cb;
    }
    .message.warning {
        background-color: #fff3cd;
        color: #856404;
        border: 1px solid #ffeaa7;
    }
    .message.info {
        background-color: #d1ecf1;
        color: #0c5460;
        border: 1px solid #bee5eb;
    }
`;
document.head.appendChild(style);

// Global functions for inline event handlers
function showCharityPromotion() {
    const votingSection = document.getElementById('voting');
    if (votingSection) {
        votingSection.scrollIntoView({ behavior: 'smooth' });
    }
}

function showAchievements() {
    const achievementsSection = document.getElementById('achievements');
    if (achievementsSection) {
        achievementsSection.scrollIntoView({ behavior: 'smooth' });
    }
}

// Initialize the faucet when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    window.roflfaucet = new ROFLFaucet();
});

// Add achievement data attributes to cards for easier targeting
document.addEventListener('DOMContentLoaded', () => {
    const achievementCards = document.querySelectorAll('.achievement-card');
    const achievementIds = [
        'first_claim',
        'democracy_supporter', 
        'satoshihost_supporter',
        'daily_streak',
        'charity_champion',
        'ecosystem_learner'
    ];
    
    achievementCards.forEach((card, index) => {
        if (achievementIds[index]) {
            card.setAttribute('data-achievement', achievementIds[index]);
        }
    });
});

